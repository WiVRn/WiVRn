/*
 * WiVRn VR streaming
 * Copyright (C) 2024  Guillaume Meunier <guillaume.meunier@centraliens.net>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "imgui_impl.h"
#include "implot.h"

#include "application.h"
#include "asset.h"
#include "constants.h"
#include "image_loader.h"
#include "openxr/openxr.h"
#include "utils/ranges.h"
#include "vulkan/vulkan_enums.hpp"
#include "vulkan/vulkan_handles.hpp"
#include "vulkan/vulkan_to_string.hpp"
#include "xr/space.h"
#include <algorithm>
#include <backends/imgui_impl_vulkan.h>
#include <boost/locale.hpp>
#include <cmath>
#include <cstddef>
#include <glm/gtc/matrix_access.hpp>
#include <imgui.h>
#include <imgui_internal.h>
#include <limits>
#include <optional>
#include <ranges>
#include <spdlog/spdlog.h>
#include <string_view>

#include "IconsFontAwesome6.h"

#ifdef __ANDROID__
#include <android/font.h>
#include <android/font_matcher.h>
#include <android/system_fonts.h>
#else
#include <fontconfig/fontconfig.h>
#endif

/* Do not use:
 *
 * ImGui_ImplVulkanH_SelectSurfaceFormat
 * ImGui_ImplVulkanH_SelectPresentMode
 * ImGui_ImplVulkanH_GetMinImageCountFromPresentMode
 * ImGui_ImplVulkanH_CreateWindowSwapChain
 * ImGui_ImplVulkanH_CreateOrResizeWindow
 * ImGui_ImplVulkanH_DestroyWindow
 *
 * struct ImGui_ImplVulkanH_Window
 */

// Automatically generated by CMakeLists
extern std::map<std::string, std::vector<int>> glyph_set_per_language;

static vk::raii::RenderPass create_renderpass(vk::raii::Device & device, vk::Format format, bool clear)
{
	vk::AttachmentDescription attachment{
	        .format = format,
	        .samples = vk::SampleCountFlagBits::e1,
	        .loadOp = clear ? vk::AttachmentLoadOp::eClear : vk::AttachmentLoadOp::eDontCare,
	        .storeOp = vk::AttachmentStoreOp::eStore,
	        .stencilLoadOp = vk::AttachmentLoadOp::eDontCare,
	        .stencilStoreOp = vk::AttachmentStoreOp::eDontCare,
	        .initialLayout = vk::ImageLayout::eUndefined,
	        .finalLayout = vk::ImageLayout::eColorAttachmentOptimal,
	};

	vk::AttachmentReference color_attachment{
	        .attachment = 0,
	        .layout = vk::ImageLayout::eColorAttachmentOptimal,
	};

	vk::SubpassDescription subpass = {
	        .pipelineBindPoint = vk::PipelineBindPoint::eGraphics,
	        .colorAttachmentCount = 1,
	        .pColorAttachments = &color_attachment,
	};

	vk::SubpassDependency dependency = {
	        .srcSubpass = VK_SUBPASS_EXTERNAL,
	        .dstSubpass = 0,
	        .srcStageMask = vk::PipelineStageFlagBits::eColorAttachmentOutput,
	        .dstStageMask = vk::PipelineStageFlagBits::eColorAttachmentOutput,
	        .srcAccessMask = {},
	        .dstAccessMask = vk::AccessFlagBits::eColorAttachmentWrite,
	};

	return vk::raii::RenderPass(
	        device, vk::RenderPassCreateInfo{
	                        .attachmentCount = 1,
	                        .pAttachments = &attachment,
	                        .subpassCount = 1,
	                        .pSubpasses = &subpass,
	                        .dependencyCount = 1,
	                        .pDependencies = &dependency,
	                });
}

static void check_vk_result(VkResult result)
{
	if (result < 0)
	{
		spdlog::error("Vulkan error in Dear ImGui: {}", vk::to_string((vk::Result)result));
		abort();
	}
}

static bool in_window(ImGuiWindow * window, ImVec2 position)
{
	if (window->Hidden or not window->Active)
		return false;

	if (window->Pos.x > position.x or
	    window->Pos.y > position.y or
	    window->Pos.x + window->Size.x < position.x or
	    window->Pos.y + window->Size.y < position.y)
		return false;

	return true;
}

static bool in_viewport(const imgui_context::viewport & viewport, ImVec2 position)
{
	if (viewport.vp_origin.x > position.x or
	    viewport.vp_origin.y > position.y or
	    viewport.vp_origin.x + viewport.vp_size.x < position.x or
	    viewport.vp_origin.y + viewport.vp_size.y < position.y)
		return false;

	return true;
}

static bool window_intersects_viewport(ImGuiWindow * window, imgui_context::viewport & viewport)
{
	ImRect w{window->Pos.x, window->Pos.y, window->Pos.x + window->Size.x, window->Pos.y + window->Size.y};
	ImRect v(viewport.vp_origin.x, viewport.vp_origin.y, viewport.vp_origin.x + viewport.vp_size.x, viewport.vp_origin.y + viewport.vp_size.y);

	return w.Overlaps(v);
}

static float distance_to_window(ImGuiWindow * window, ImVec2 position)
{
	if (window->Hidden or not window->Active)
		return std::numeric_limits<float>::infinity();

	float dx;
	if (position.x < window->Pos.x)
		dx = window->Pos.x - position.x;
	else if (position.x > window->Pos.x + window->Size.x)
		dx = position.x - (window->Pos.x + window->Size.x);
	else
		dx = 0;

	float dy;
	if (position.y < window->Pos.y)
		dy = window->Pos.y - position.y;
	else if (position.y > window->Pos.y + window->Size.y)
		dy = position.y - (window->Pos.y + window->Size.y);
	else
		dy = 0;

	return std::hypot(dx, dy);
}

std::vector<std::pair<ImVec2, float>> imgui_context::ray_plane_intersection(const imgui_context::controller_state & in) const
{
	if (!in.active)
		return {};

	std::vector<std::pair<ImVec2, float>> intersections;

	for (const auto & i: layers_)
	{
		if (i.space != xr::spaces::world)
			continue;

		auto M = glm::transpose(glm::mat3_cast(i.orientation)); // world-to-plane transform

		glm::quat q = (in.source == ImGuiMouseSource_VRHandTracking) ? i.orientation : in.aim_orientation;
		glm::vec3 controller_direction = -glm::column(glm::mat3_cast(q), 2); // The aim direction is -Z

		// Compute all vectors in the reference frame of the GUI plane
		glm::vec3 ray_start = M * (in.aim_position - i.position);
		glm::vec3 ray_dir = M * controller_direction;

		if (ray_dir.z < -0.0001f)
		{
			glm::vec2 coord;

			// ray_start + distance × ray_dir ∈ imgui plane
			// => ray_start.z + distance × ray_dir.z = 0
			float distance = -ray_start.z / ray_dir.z;

			if (distance < constants::gui::min_pointer_distance)
				continue;

			coord.x = ray_start.x + distance * ray_dir.x;
			coord.y = ray_start.y + distance * ray_dir.y;

			// Convert from mesh coordinates to imgui coordinates
			coord = coord / i.size;

			if (fabs(coord.x) > 0.5 or fabs(coord.y) > 0.5)
				continue;

			intersections.emplace_back(ImVec2(
			                                   (0.5 + coord.x) * i.vp_size.x + i.vp_origin.x,
			                                   (0.5 - coord.y) * i.vp_size.y + i.vp_origin.y),
			                           distance);
		}
	}

	std::ranges::sort(intersections, [](auto & a, auto & b) { return a.second < b.second; });

	return intersections;
}

glm::vec3 imgui_context::rw_from_vp(const ImVec2 & position)
{
	for (auto & i: layers_)
	{
		if (not in_viewport(i, position))
			continue;

		return i.position + glm::mat3_cast(i.orientation) * glm::vec3{
		                                                            ((position.x - i.vp_origin.x) / i.vp_size.x - 0.5) * i.size.x,
		                                                            (-(position.y - i.vp_origin.y) / i.vp_size.y + 0.5) * i.size.y,
		                                                            0};
	}

	return {};
}

imgui_context::imgui_frame & imgui_context::get_frame(vk::Image destination)
{
	for (auto & i: frames)
	{
		if (i.destination == destination)
			return i;
	}

	auto & frame = frames.emplace_back();

	frame.destination = destination;

	// Only 1 mipmap level for the framebuffer view
	frame.image_view_framebuffer = vk::raii::ImageView(
	        device,
	        vk::ImageViewCreateInfo{
	                .image = destination,
	                .viewType = vk::ImageViewType::e2D,
	                .format = format,
	                .subresourceRange = {
	                        .aspectMask = vk::ImageAspectFlagBits::eColor,
	                        .baseMipLevel = 0,
	                        .levelCount = 1,
	                        .baseArrayLayer = 0,
	                        .layerCount = 1,
	                },
	        });

	frame.framebuffer = vk::raii::Framebuffer(
	        device,
	        vk::FramebufferCreateInfo{
	                .renderPass = *renderpass,
	                .attachmentCount = 1,
	                .pAttachments = &*frame.image_view_framebuffer,
	                .width = size.width,
	                .height = size.height,
	                .layers = 1,
	        });

	return frame;
}

static const std::array layout_bindings = {
        vk::DescriptorSetLayoutBinding{
                .binding = 0,
                .descriptorType = vk::DescriptorType::eCombinedImageSampler,
                .descriptorCount = 1,
                .stageFlags = vk::ShaderStageFlagBits::eFragment,
        }};

imgui_context::imgui_context(
        vk::raii::PhysicalDevice physical_device,
        vk::raii::Device & device,
        uint32_t queue_family_index,
        thread_safe<vk::raii::Queue> & queue,
        std::span<controller> controllers_,
        xr::swapchain & swapchain,
        std::vector<viewport> layers) :
        physical_device(physical_device),
        device(device),
        queue_family_index(queue_family_index),
        queue(queue),
        ds_layout(device, vk::DescriptorSetLayoutCreateInfo{.bindingCount = layout_bindings.size(), .pBindings = layout_bindings.data()}),
        descriptor_pool(device, ds_layout, layout_bindings),
        renderpass(create_renderpass(device, swapchain.format(), true)),
        command_pool(device,
                     vk::CommandPoolCreateInfo{
                             .flags = vk::CommandPoolCreateFlagBits::eResetCommandBuffer | vk::CommandPoolCreateFlagBits::eTransient,
                             .queueFamilyIndex = queue_family_index,
                     }),
        command_buffers(swapchain.images().size()),
        size(swapchain.extent().width, swapchain.extent().height),
        format(swapchain.format()),
        layers_(std::move(layers)),
        swapchain(swapchain),
        context(ImGui::CreateContext()),
        plot_context(ImPlot::CreateContext()),
        io((ImGui::SetCurrentContext(context), ImGui::GetIO())),
        world(application::space(xr::spaces::world))
{
	controllers.reserve(controllers_.size());
	for (const auto & i: controllers_)
		controllers.emplace_back(i, controller_state{});

	io.IniFilename = nullptr;

	for (command_buffer & cb: command_buffers)
	{
		cb.command_buffer = std::move(device.allocateCommandBuffers({
		        .commandPool = *command_pool,
		        .commandBufferCount = 1,
		})[0]);

		cb.fence = device.createFence(vk::FenceCreateInfo{.flags = vk::FenceCreateFlagBits::eSignaled});
	}

	ImGui_ImplVulkan_InitInfo init_info = {
	        .Instance = *application::get_vulkan_instance(),
	        .PhysicalDevice = *application::get_physical_device(),
	        .Device = *application::get_device(),
	        .QueueFamily = application::queue_family_index(),
	        .Queue = *queue.get_unsafe(),
	        .RenderPass = *renderpass,
	        .MinImageCount = 2,
	        .ImageCount = (uint32_t)swapchain.images().size(), // used to cycle between VkBuffers in ImGui_ImplVulkan_RenderDrawData
	        .MSAASamples = VK_SAMPLE_COUNT_1_BIT,
	        .PipelineCache = *application::get_pipeline_cache(),
	        .Subpass = 0,
	        .DescriptorPoolSize = 100,
	        .Allocator = nullptr,
	        .CheckVkResultFn = check_vk_result,
	};

	ImGui::SetCurrentContext(context);
	ImPlot::SetCurrentContext(plot_context);
	ImGui_ImplVulkan_Init(&init_info);

	initialize_fonts();

	// Setup Dear ImGui style
	ImGui::StyleColorsDark();
	// ImGui::StyleColorsClassic();
	// ImGui::StyleColorsLight();

	ImGuiStyle & style = ImGui::GetStyle();

	style.WindowBorderSize = 0;
	style.DisabledAlpha = 0.2;
	style.Colors[ImGuiCol_ModalWindowDimBg] = {0, 0, 0, 0};
}

#ifdef __ANDROID__
static std::vector<std::string> find_font(std::u16string_view sample_text, const std::string & locale)
{
	AFontMatcher * font_matcher = AFontMatcher_create();
	if (!font_matcher)
		throw std::runtime_error("AFontMatcher_create");

	AFontMatcher_setFamilyVariant(font_matcher, AFAMILY_VARIANT_DEFAULT);
	AFontMatcher_setLocales(font_matcher, locale.c_str());
	AFontMatcher_setStyle(font_matcher, AFONT_WEIGHT_NORMAL, false);

	std::vector<std::string> fonts;

	while (!sample_text.empty())
	{
		uint32_t runlength = 0;

		AFont * font = AFontMatcher_match(font_matcher, "sans-serif", (uint16_t *)sample_text.data(), sample_text.size(), &runlength);
		fonts.emplace_back(AFont_getFontFilePath(font));
		AFont_close(font);

		if (runlength == 0)
			break;

		sample_text = sample_text.substr(runlength);
	}

	AFontMatcher_destroy(font_matcher);

	return fonts;
}
#else
static std::vector<std::string> find_font(std::u16string sample_text, const std::string & locale)
{
	// See https://www.camconn.cc/post/how-to-fontconfig-lib-c/

	static FcConfig * config = FcInitLoadConfigAndFonts();

	FcPattern * pattern = FcNameParse((const FcChar8 *)constants::gui::font_name);
	if (!pattern)
		throw std::runtime_error("Failed to create Fontconfig pattern");

	FcConfigSubstitute(config, pattern, FcMatchPattern);
	FcDefaultSubstitute(pattern);

	// Add the locale/language to the pattern
	FcPatternAddString(pattern, FC_LANG, (const FcChar8 *)locale.c_str());

	// Add the text to the pattern (to determine appropriate characters)
	FcCharSet * charset = FcCharSetCreate();

	for (char16_t c: sample_text)
		FcCharSetAddChar(charset, c);

	FcPatternAddCharSet(pattern, FC_CHARSET, charset);
	FcCharSetDestroy(charset);

	auto fs = FcFontSetCreate();

	FcResult result;
	FcFontSet * font_patterns = FcFontSort(config, pattern, FcTrue, nullptr, &result);

	if (!font_patterns || font_patterns->nfont == 0)
	{
		FcFontSetDestroy(fs);
		FcPatternDestroy(pattern);
		throw std::runtime_error("Fontconfig could not find ANY fonts on the system?");
	}

	std::vector<std::string> fonts;
	for (int i = 0; i < font_patterns->nfont; i++)
	{
		FcChar8 * font_file;
		if (FcPatternGetString(font_patterns->fonts[i], FC_FILE, 0, &font_file) != FcResultMatch)
			continue;

		FcCharSet * font_charset;
		if (FcPatternGetCharSet(font_patterns->fonts[i], FC_CHARSET, 0, &font_charset) != FcResultMatch)
			continue;

		bool keep_this_font = false;

		std::u16string tmp = sample_text;
		for (int i = 0; i < tmp.size();)
		{
			char16_t c = tmp[i];

			if (FcCharSetHasChar(font_charset, c))
			{
				keep_this_font = true;

				tmp[i] = tmp[tmp.size() - 1];
				tmp.resize(tmp.size() - 1);
			}
			else
				++i;
		}

		if (keep_this_font)
			fonts.emplace_back((const char *)font_file);
		break;
	}

	FcFontSetDestroy(fs);
	FcPatternDestroy(pattern);

	return fonts;
}
#endif

void imgui_context::initialize_fonts()
{
	std::u16string sample_text = u"Hello world";

	const auto & locale = application::get_messages_info();
	auto it = glyph_set_per_language.find(locale.language + "_" + locale.country);
	if (it == glyph_set_per_language.end())
		it = glyph_set_per_language.find(locale.language);

	if (it != glyph_set_per_language.end())
		for (char16_t c: it->second)
			sample_text += c;

	// Load Fonts
	auto fonts = find_font(sample_text, application::get_messages_info().language);
	for (auto & i: fonts)
	{
		spdlog::info("Font {}", i);
	}

	asset font_awesome_regular("Font Awesome 6 Free-Regular-400.otf");
	asset font_awesome_solid("Font Awesome 6 Free-Solid-900.otf");

	ImFontConfig config;
	config.FontDataOwnedByAtlas = false;

	for (auto & font: fonts)
	{
		spdlog::info("Using font {}", font, application::get_messages_info().language);
		io.Fonts->AddFontFromFileTTF(font.c_str(), constants::gui::font_size_small, &config);
		config.MergeMode = true;
	}

	config.MergeMode = true;
	config.GlyphMinAdvanceX = 40; // Use if you want to make the icon monospaced
	io.Fonts->AddFontFromMemoryTTF(const_cast<std::byte *>(font_awesome_regular.data()), font_awesome_regular.size(), constants::gui::font_size_small, &config);
	io.Fonts->AddFontFromMemoryTTF(const_cast<std::byte *>(font_awesome_solid.data()), font_awesome_solid.size(), constants::gui::font_size_small, &config);
}

std::vector<imgui_context::controller_state> imgui_context::read_controllers_state(XrTime display_time)
{
	float scroll_scale = io.DeltaTime * constants::gui::scroll_ratio;
	size_t new_focused_controller = focused_controller;

	std::vector<controller_state> new_states;

	// Get the hand/controller state from OpenXR
	for (auto && [index, controller]: utils::enumerate(controllers))
	{
		auto & [ctrl, state] = controller;

		controller_state & new_state = new_states.emplace_back();

		if (not controllers_enabled)
			continue;

		if (ctrl.hand)
		{
			if (auto joints = ctrl.hand->locate(world, display_time))
			{
				XrHandJointLocationEXT & index_tip = (*joints)[XR_HAND_JOINT_INDEX_TIP_EXT].first;
				if (index_tip.locationFlags & XR_SPACE_LOCATION_POSITION_TRACKED_BIT)
				{
					new_state.aim_position = {
					        index_tip.pose.position.x,
					        index_tip.pose.position.y,
					        index_tip.pose.position.z};
					// aim_orientation is ignored by ray_plane_intersection() for hands

					new_state.active = true;
					new_state.source = ImGuiMouseSource_VRHandTracking;
				}
			}

			continue;
		}

		new_state.source = ImGuiMouseSource_VRController;

		if (auto location = application::locate_controller(ctrl.aim, world, display_time))
		{
			new_state.active = true;
			new_state.aim_position = location->first + glm::mat3_cast(location->second * ctrl.offset.second) * ctrl.offset.first;
			new_state.aim_orientation = location->second * ctrl.offset.second;

			if (ctrl.trigger)
			{
				auto trigger = application::read_action_float(ctrl.trigger).value_or(std::pair{0, 0});
				new_state.trigger_value = trigger.second;

				// TODO tunable
				/*if (new_state.trigger_value < 0.5)
				        new_state.trigger_clicked = false;
				else */
				if (new_state.trigger_value > constants::gui::trigger_click_thd)
					new_state.trigger_clicked = true;
			}

			if (ctrl.scroll)
			{
				if (auto act = application::read_action_vec2(ctrl.scroll); act)
					new_state.scroll_value = {-act->second.x * scroll_scale, act->second.y * scroll_scale};
				else
					new_state.scroll_value = {0, 0};
			}
		}
	}

	// Compute the position in imgui frame according to the currently displayed windows (from the last frame)
	for (auto & state: new_states)
	{
		compute_pointer_position(state);

		if (state.source == ImGuiMouseSource_VRHandTracking)
		{
			if (state.hover_distance < constants::gui::fingertip_distance_hovering_thd)
				state.fingertip_hovering = true;

			if (state.hover_distance < constants::gui::fingertip_distance_touching_thd)
				state.fingertip_touching = true;
		}
	}

	return new_states;
}

void imgui_context::compute_pointer_position(imgui_context::controller_state & state)
{
	auto intersections = ray_plane_intersection(state);

	if (intersections.empty())
	{
		state.hover_distance = std::numeric_limits<float>::infinity();
		state.pointer_position = std::nullopt;
		return;
	}

	if (ImGuiWindow * modal_popup = ImGui::GetTopMostAndVisiblePopupModal())
	{
		// If there is a popup window, use the viewport of that window or the virtual keyboard
		for (auto & i: layers_)
		{
			if (i.space != xr::spaces::world)
				continue;

			if (window_intersects_viewport(modal_popup, i) or i.always_show_cursor)
			{
				for (auto [position, distance]: intersections)
				{
					if (in_viewport(i, position))
					{
						state.hover_distance = distance;
						state.pointer_position = position;
						return;
					}
				}
			}
		}

		state.hover_distance = std::numeric_limits<float>::infinity();
		state.pointer_position = std::nullopt;
	}
	else
	{
		// Intersections are sorted by distance: take the closest one
		for (auto [position, distance]: intersections)
		{
			for (ImGuiWindow * window: context->Windows)
			{
				if (not window->Active or window->Hidden)
					continue;

				if (in_window(window, position))
				{
					state.hover_distance = distance;
					state.pointer_position = position;
					return;
				}
			}
		}

		// If the pointer isn't in any window, take the farthest one
		std::tie(state.pointer_position, state.hover_distance) = intersections.back();
	}
}

size_t imgui_context::choose_focused_controller(const std::vector<controller_state> & new_states) const
{
	// If only one controller points at a GUI layer, select it
	size_t new_focused_controller = (size_t)-1;
	size_t count = 0;
	for (auto && [index, state]: utils::enumerate(new_states))
	{
		if (state.pointer_position)
		{
			count++;
			new_focused_controller = index;
		}
	}

	if (count == 1)
		return new_focused_controller;

	// If there is a rising edge on a trigger, select the controller
	assert(controllers.size() == new_states.size());
	for (size_t index = 0, size = controllers.size(); index < size; ++index)
	{
		const auto & old_state = controllers[index].second;
		const auto & new_state = new_states[index];

		bool old_click = (old_state.source == ImGuiMouseSource_VRController and old_state.trigger_clicked) or
		                 (old_state.source == ImGuiMouseSource_VRHandTracking and old_state.fingertip_touching);

		bool new_click = (new_state.source == ImGuiMouseSource_VRController and new_state.trigger_clicked) or
		                 (new_state.source == ImGuiMouseSource_VRHandTracking and new_state.fingertip_touching);

		if (not old_click and new_click)
			return index;
	}

	// Else, keep the last controller active
	return focused_controller;
}

void imgui_context::new_frame(XrTime display_time)
{
	ImGui::SetCurrentContext(context);
	ImPlot::SetCurrentContext(plot_context);

	if (last_display_time)
		io.DeltaTime = std::min((display_time - last_display_time) * 1e-9f, 0.0166f);
	last_display_time = display_time;

	// Uses the window list from last frame
	auto new_states = read_controllers_state(display_time);

	// Set the currently active controller
	size_t new_focused_controller = choose_focused_controller(new_states);

	bool focused_change = new_focused_controller != focused_controller && focused_controller != (size_t)-1;

	// Set the source for the following events
	if (focused_controller != (size_t)-1)
		io.AddMouseSourceEvent(new_states[focused_controller].source);

	if (new_focused_controller != (size_t)-1)
	{
		auto scroll = new_states[new_focused_controller].scroll_value;

		button_pressed = new_states[new_focused_controller].trigger_clicked;
		fingertip_touching = new_states[new_focused_controller].fingertip_touching;

		// Focused controller changed: end the current click for this frame
		io.AddMouseButtonEvent(0, (button_pressed or fingertip_touching) and not focused_change);

		if (auto position = new_states[new_focused_controller].pointer_position)
		{
			io.AddMousePosEvent(position->x, position->y);

			if (glm::length(scroll) > constants::gui::scroll_value_thd)
			{
				io.MouseWheel = scroll.y;
				io.MouseWheelH = scroll.x;
			}
		}
	}

	focused_controller = new_focused_controller;
	for (auto && [controller, next_state]: std::views::zip(controllers, new_states))
	{
		controller.second = next_state;
	}

	// Start the Dear ImGui frame
	ImGui_ImplVulkan_NewFrame();

	io.DisplaySize = ImVec2(size.width, size.height);
	io.DisplayFramebufferScale = ImVec2(1, 1);

	// See ImGui_ImplSDL2_ProcessEvent

	ImGui::NewFrame();

#if WIVRN_SHOW_IMGUI_DEMO_WINDOW
	if (show_demo_window)
		ImGui::ShowDemoWindow(&show_demo_window);
#endif

	image_index = swapchain.acquire();
	swapchain.wait();

	hovered_item_prev = hovered_item;
	hovered_item = 0;
}

std::vector<std::pair<int, XrCompositionLayerQuad>> imgui_context::end_frame()
{
	if (hovered_item != hovered_item_prev && hovered_item != 0)
	{
		size_t controller = get_focused_controller();
		if (auto haptic_output = controllers[controller].first.haptic_output; haptic_output != XR_NULL_HANDLE)
			application::haptic_start(haptic_output, XR_NULL_PATH, 10'000'000, 1000, 1);
	}

	vk::Image destination = swapchain.images()[image_index].image;

	ImGui::SetCurrentContext(context);
	ImPlot::SetCurrentContext(plot_context);

	for (auto & controller: controllers)
	{
		if (auto position = controller.second.pointer_position)
		{
			// Clip in the right plane
			ImVec2 clip_rect_min(0, 0);
			ImVec2 clip_rect_max(0, 0);

			// If there is a modal popup, only display the cursor in the viewport of the popup or on the virtual keyboard
			if (ImGuiWindow * modal_popup = ImGui::GetTopMostAndVisiblePopupModal())
			{
				for (auto & i: layers_)
				{
					if (i.space != xr::spaces::world)
						continue;

					// The cursor is over the virtual keyboard
					if (i.always_show_cursor and
					    position->x >= i.vp_origin.x and
					    position->y >= i.vp_origin.y and
					    position->x <= i.vp_origin.x + i.vp_size.x and
					    position->y <= i.vp_origin.y + i.vp_size.y)
					{
						clip_rect_min = ImVec2(i.vp_origin.x + 1, i.vp_origin.y + 1);
						clip_rect_max = ImVec2(i.vp_origin.x + i.vp_size.x, i.vp_origin.y + i.vp_size.y);
						break;
					}

					// The cursor is in the same viewport as the popup
					if (window_intersects_viewport(modal_popup, i) and
					    position->x >= i.vp_origin.x and
					    position->y >= i.vp_origin.y and
					    position->x <= i.vp_origin.x + i.vp_size.x and
					    position->y <= i.vp_origin.y + i.vp_size.y)
					{
						clip_rect_min = ImVec2(i.vp_origin.x + 1, i.vp_origin.y + 1);
						clip_rect_max = ImVec2(i.vp_origin.x + i.vp_size.x, i.vp_origin.y + i.vp_size.y);
						break;
					}
				}
			}
			else
			{
				for (auto & i: layers_)
				{
					if (position->x < i.vp_origin.x or
					    position->y < i.vp_origin.y or
					    position->x > i.vp_origin.x + i.vp_size.x or
					    position->y > i.vp_origin.y + i.vp_size.y)
						continue;

					clip_rect_min = ImVec2(i.vp_origin.x + 1, i.vp_origin.y + 1);
					clip_rect_max = ImVec2(i.vp_origin.x + i.vp_size.x, i.vp_origin.y + i.vp_size.y);

					break;
				}
			}

			// Compute the distance to the closest window
			float distance = std::numeric_limits<float>::infinity();
			for (ImGuiWindow * window: context->Windows)
			{
				distance = std::min(distance, distance_to_window(window, *position));
			}

			float alpha = std::clamp<float>(1 - distance / constants::gui::pointer_fading_distance, 0, 1);

			if (&controller == &controllers[focused_controller])
				alpha *= constants::gui::pointer_alpha;
			else
				alpha *= constants::gui::pointer_alpha_disabled;

			ImU32 color_pressed = ImGui::GetColorU32(constants::gui::pointer_color_pressed, alpha);
			ImU32 color_unpressed = ImGui::GetColorU32(constants::gui::pointer_color_unpressed, alpha);

			bool pressed = controller.second.trigger_clicked || controller.second.fingertip_touching;

			ImDrawList * draw_list = ImGui::GetForegroundDrawList();
			draw_list->PushClipRect(clip_rect_min, clip_rect_max);
			draw_list->AddCircleFilled(*position, constants::gui::pointer_radius_in, pressed ? color_pressed : color_unpressed);
			draw_list->AddCircle(*position, constants::gui::pointer_radius_out, ImGui::GetColorU32(constants::gui::pointer_color_border, alpha), 0, constants::gui::pointer_thickness);
			draw_list->PopClipRect();
		}
	}

	ImGui::Render();

	current_command_buffer = (current_command_buffer + 1) % command_buffers.size();

	auto & f = get_frame(destination);
	auto & cb = get_command_buffer().command_buffer;
	auto & fence = get_command_buffer().fence;

	if (auto result = device.waitForFences(*fence, true, 1'000'000'000); result != vk::Result::eSuccess)
		throw std::runtime_error("vkWaitForfences: " + vk::to_string(result));
	device.resetFences(*fence);

	cb.begin({.flags = vk::CommandBufferUsageFlagBits::eOneTimeSubmit});

	vk::ClearValue clear{vk::ClearColorValue(0, 0, 0, 0)};

	cb.beginRenderPass(vk::RenderPassBeginInfo{
	                           .renderPass = *renderpass,
	                           .framebuffer = *f.framebuffer,
	                           .renderArea = {
	                                   .extent = size,
	                           },
	                           .clearValueCount = 1,
	                           .pClearValues = &clear},
	                   vk::SubpassContents::eInline);

	{
		auto _ = queue.lock(); // ImGui_ImplVulkan_RenderDrawData uses the queue internally (in ImGui_ImplVulkan_UpdateTexture)
		// TODO: patch imgui_impl_vulkan to accept a mutex
		ImGui_ImplVulkan_RenderDrawData(ImGui::GetDrawData(), *cb);
	}

	cb.endRenderPass();

	cb.end();

	queue.lock()->submit(vk::SubmitInfo{
	                             .commandBufferCount = 1,
	                             .pCommandBuffers = &*cb,
	                     },
	                     *fence);

	swapchain.release();

	std::vector<std::pair<int, XrCompositionLayerQuad>> quads;
	quads.reserve(layers_.size());

	for (auto & i: layers_)
	{
		bool visible = false;
		for (ImGuiWindow * window: context->Windows)
		{
			if (window->Active and not window->Hidden and window_intersects_viewport(window, i))
			{
				visible = true;
				break;
			}
		}

		if (not visible)
			continue;

		quads.emplace_back(
		        i.z_index,
		        XrCompositionLayerQuad{
		                .type = XR_TYPE_COMPOSITION_LAYER_QUAD,
		                .layerFlags = XR_COMPOSITION_LAYER_BLEND_TEXTURE_SOURCE_ALPHA_BIT,
		                .space = application::space(i.space),
		                .eyeVisibility = XrEyeVisibility::XR_EYE_VISIBILITY_BOTH,
		                .subImage = {
		                        .swapchain = swapchain,
		                        .imageRect = {
		                                .offset = {
		                                        .x = i.vp_origin.x,
		                                        .y = i.vp_origin.y,
		                                },
		                                .extent = {
		                                        .width = i.vp_size.x,
		                                        .height = i.vp_size.y,
		                                }},
		                },
		                .pose = {
		                        .orientation = {
		                                .x = i.orientation.x,
		                                .y = i.orientation.y,
		                                .z = i.orientation.z,
		                                .w = i.orientation.w,
		                        },
		                        .position = {
		                                .x = i.position.x,
		                                .y = i.position.y,
		                                .z = i.position.z,
		                        },
		                },
		                .size = {
		                        .width = i.size.x,
		                        .height = i.size.y,
		                },
		        });
	}

	return quads;
}

void imgui_context::vibrate_on_hover()
{
	if (ImGui::IsItemHovered())
		hovered_item = ImGui::GetItemID();
}

void imgui_context::set_hovered_item()
{
	hovered_item = ImGui::GetItemID();
}

imgui_context::~imgui_context()
{
	ImGui::SetCurrentContext(context);
	ImPlot::SetCurrentContext(plot_context);

	std::vector<vk::Fence> fences;

	// Release the command buffers without freing them, they will be destroyed with the command pool
	for (auto & f: command_buffers)
	{
		f.command_buffer.release();
		fences.push_back(*f.fence);
	}

	// Wait for fences before ImGui_ImplVulkan_Shutdown is called
	if (auto result = device.waitForFences(fences, true, 1'000'000'000); result != vk::Result::eSuccess)
		spdlog::error("vkWaitForfences: {}", vk::to_string(result));

	ImGui_ImplVulkan_Shutdown();
	ImPlot::DestroyContext();
	ImGui::DestroyContext(context);
}

ImTextureID imgui_context::load_texture(const std::string & filename, vk::raii::Sampler && sampler)
{
	return load_texture(std::span<const std::byte>{asset{filename}}, std::move(sampler));
}

ImTextureID imgui_context::load_texture(const std::span<const std::byte> & bytes, vk::raii::Sampler && sampler)
{
	bool srgb = true;
	image_loader loader(physical_device, device, queue, command_pool);
	loader.load(bytes, srgb);

	std::shared_ptr<vk::raii::DescriptorSet> ds = descriptor_pool.allocate();

	vk::DescriptorImageInfo image_info{
	        .sampler = *sampler,
	        .imageView = **loader.image_view,
	        .imageLayout = vk::ImageLayout::eShaderReadOnlyOptimal,
	};

	vk::WriteDescriptorSet ds_write{
	        .dstSet = **ds,
	        .descriptorCount = 1,
	        .descriptorType = vk::DescriptorType::eCombinedImageSampler,
	        .pImageInfo = &image_info};

	device.updateDescriptorSets(ds_write, nullptr);

	ImTextureID id = reinterpret_cast<ImTextureID>(VkDescriptorSet(**ds));

	textures.emplace(
	        id,
	        texture_data{
	                .sampler = std::move(sampler),
	                // .image = std::move(loader.image),
	                .image_view = std::move(loader.image_view),
	                .descriptor_set = std::move(ds),
	        });

	return id;
}

ImTextureID imgui_context::load_texture(const std::span<const std::byte> & bytes)
{
	return load_texture(
	        bytes,
	        vk::raii::Sampler{
	                device,
	                vk::SamplerCreateInfo{
	                        .magFilter = vk::Filter::eLinear,
	                        .minFilter = vk::Filter::eLinear,
	                        .mipmapMode = vk::SamplerMipmapMode::eLinear,
	                        .addressModeU = vk::SamplerAddressMode::eClampToEdge,
	                        .addressModeV = vk::SamplerAddressMode::eClampToEdge,
	                        .addressModeW = vk::SamplerAddressMode::eClampToEdge,
	                        .borderColor = vk::BorderColor::eFloatTransparentBlack,
	                },
	        });
}

ImTextureID imgui_context::load_texture(const std::string & filename)
{
	return load_texture(
	        filename,
	        vk::raii::Sampler{
	                device,
	                vk::SamplerCreateInfo{
	                        .magFilter = vk::Filter::eLinear,
	                        .minFilter = vk::Filter::eLinear,
	                        .mipmapMode = vk::SamplerMipmapMode::eLinear,
	                        .addressModeU = vk::SamplerAddressMode::eClampToEdge,
	                        .addressModeV = vk::SamplerAddressMode::eClampToEdge,
	                        .addressModeW = vk::SamplerAddressMode::eClampToEdge,
	                        .borderColor = vk::BorderColor::eFloatTransparentBlack,
	                },
	        });
}

void imgui_context::free_texture(ImTextureID texture)
{
	textures.erase(texture);
}

void imgui_context::set_current()
{
	ImGui::SetCurrentContext(context);
	ImPlot::SetCurrentContext(plot_context);
}

void imgui_context::set_controllers_enabled(bool value)
{
	controllers_enabled = value;
}

bool imgui_context::is_modal_popup_shown() const
{
	return ImGui::GetTopMostAndVisiblePopupModal() != nullptr;
}

imgui_context::viewport & imgui_context::layer(ImVec2 position)
{
	for (auto & layer: layers_)
	{
		if (in_viewport(layer, position))
			return layer;
	}

	return layers_.front();
}

void imgui_context::tooltip(std::string_view text)
{
	// FIXME: this is incorrect if we use the docking branch of imgui
	ImGuiViewport * viewport = ImGui::GetMainViewport();
	auto & current_layer = layer(ImGui::GetMousePos());
	auto pos_backup = viewport->Pos;
	auto size_backup = viewport->Size;
	viewport->Pos = ImVec2(current_layer.vp_origin.x, current_layer.vp_origin.y);
	viewport->Size = ImVec2(current_layer.vp_size.x, current_layer.vp_size.y);

	ImVec2 pos{
	        (ImGui::GetItemRectMin().x + ImGui::GetItemRectMax().x) / 2,
	        ImGui::GetItemRectMin().y - constants::style::tooltip_distance,
	};

	ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, constants::style::tooltip_padding);
	ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, constants::style::tooltip_rounding);

	// Clamp position to avoid overflowing on the left or the right
	auto & style = ImGui::GetStyle();
	const ImVec2 text_size = ImGui::CalcTextSize(text.data(), text.data() + text.size(), true);
	const ImVec2 size = {text_size.x + style.WindowPadding.x * 2.0f, text_size.y + style.WindowPadding.y * 2.0f};
	pos.x = std::clamp<float>(pos.x, viewport->Pos.x + size.x / 2, viewport->Pos.x + viewport->Size.x - size.x / 2);
	ImVec2 pivot = {0.5, 1};

	// Move tooltip below the item if it overflows on the top
	if (pos.y - size.y <= viewport->Pos.y)
	{
		pos.y = ImGui::GetItemRectMax().y + constants::style::tooltip_distance;
		pivot.y = 0;
	}

	ImGui::SetNextWindowPos(pos, ImGuiCond_Always, pivot);
	if (ImGui::BeginTooltip())
	{
		ImGui::PushStyleColor(ImGuiCol_Text, 0xffffffff);
		ImGui::TextUnformatted(text.data(), text.data() + text.size());
		ImGui::PopStyleColor();
		ImGui::EndTooltip();
	}

	ImGui::PopStyleVar(2);

	viewport->Pos = pos_backup;
	viewport->Size = size_backup;
}
