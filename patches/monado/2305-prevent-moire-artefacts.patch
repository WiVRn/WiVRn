diff --git a/src/xrt/compositor/main/comp_renderer.c b/src/xrt/compositor/main/comp_renderer.c
index 1b295a324..baabd2a0c 100644
--- a/src/xrt/compositor/main/comp_renderer.c
+++ b/src/xrt/compositor/main/comp_renderer.c
@@ -1037,6 +1037,9 @@ dispatch_compute(struct comp_renderer *r,
 		// Scratch image covers the whole image.
 		struct xrt_normalized_rect layer_norm_rect = {.x = 0.0f, .y = 0.0f, .w = 1.0f, .h = 1.0f};
 
+		data.cs.scratch_size[i].x = c->scratch.views[i].info.width;
+		data.cs.scratch_size[i].y = c->scratch.views[i].info.height;
+
 		comp_render_cs_add_view(  //
 		    &data,                // data
 		    &world_poses[i],      // world_pose
diff --git a/src/xrt/compositor/render/render_compute.c b/src/xrt/compositor/render/render_compute.c
index dadb35ddc..3c3effd7d 100644
--- a/src/xrt/compositor/render/render_compute.c
+++ b/src/xrt/compositor/render/render_compute.c
@@ -455,6 +455,7 @@ render_compute_projection_timewarp(struct render_compute *crc,
                                    VkSampler src_samplers[XRT_MAX_VIEWS],
                                    VkImageView src_image_views[XRT_MAX_VIEWS],
                                    const struct xrt_normalized_rect src_norm_rects[XRT_MAX_VIEWS],
+                                   const struct xrt_vec2 src_sizes[XRT_MAX_VIEWS],
                                    const struct xrt_pose src_poses[XRT_MAX_VIEWS],
                                    const struct xrt_fov src_fovs[XRT_MAX_VIEWS],
                                    const struct xrt_pose new_poses[XRT_MAX_VIEWS],
@@ -488,6 +489,8 @@ render_compute_projection_timewarp(struct render_compute *crc,
 		data->pre_transforms[i] = r->distortion.uv_to_tanangle[i];
 		data->transforms[i] = time_warp_matrix[i];
 		data->post_transforms[i] = src_norm_rects[i];
+		data->source_sizes[i].x = src_sizes[i].x;
+		data->source_sizes[i].y = src_sizes[i].y;
 	}
 
 	/*
@@ -592,6 +595,7 @@ render_compute_projection(struct render_compute *crc,
                           VkSampler src_samplers[XRT_MAX_VIEWS],
                           VkImageView src_image_views[XRT_MAX_VIEWS],
                           const struct xrt_normalized_rect src_norm_rects[XRT_MAX_VIEWS],
+                          const struct xrt_vec2 src_sizes[XRT_MAX_VIEWS],
                           VkImage target_image,
                           VkImageView target_image_view,
                           const struct render_viewport_data views[XRT_MAX_VIEWS])
@@ -611,6 +615,8 @@ render_compute_projection(struct render_compute *crc,
 	for (uint32_t i = 0; i < crc->r->view_count; ++i) {
 		data->views[i] = views[i];
 		data->post_transforms[i] = src_norm_rects[i];
+		data->source_sizes[i].x = src_sizes[i].x;
+		data->source_sizes[i].y = src_sizes[i].y;
 	}
 
 
diff --git a/src/xrt/compositor/render/render_interface.h b/src/xrt/compositor/render/render_interface.h
index f1a7a941a..fcb6dcc44 100644
--- a/src/xrt/compositor/render/render_interface.h
+++ b/src/xrt/compositor/render/render_interface.h
@@ -1227,6 +1227,7 @@ struct render_compute_distortion_ubo_data
 	struct xrt_normalized_rect pre_transforms[XRT_MAX_VIEWS];
 	struct xrt_normalized_rect post_transforms[XRT_MAX_VIEWS];
 	struct xrt_matrix_4x4 transforms[XRT_MAX_VIEWS];
+	struct xrt_rect_f32 source_sizes[XRT_MAX_VIEWS];
 };
 
 /*!
@@ -1294,6 +1295,7 @@ render_compute_projection_timewarp(struct render_compute *crc,
                                    VkSampler src_samplers[XRT_MAX_VIEWS],
                                    VkImageView src_image_views[XRT_MAX_VIEWS],
                                    const struct xrt_normalized_rect src_rects[XRT_MAX_VIEWS],
+                                   const struct xrt_vec2 src_sizes[XRT_MAX_VIEWS],
                                    const struct xrt_pose src_poses[XRT_MAX_VIEWS],
                                    const struct xrt_fov src_fovs[XRT_MAX_VIEWS],
                                    const struct xrt_pose new_poses[XRT_MAX_VIEWS],
@@ -1309,6 +1311,7 @@ render_compute_projection(struct render_compute *crc,
                           VkSampler src_samplers[XRT_MAX_VIEWS],                     //
                           VkImageView src_image_views[XRT_MAX_VIEWS],                //
                           const struct xrt_normalized_rect src_rects[XRT_MAX_VIEWS], //
+                          const struct xrt_vec2 src_sizes[XRT_MAX_VIEWS],            //
                           VkImage target_image,                                      //
                           VkImageView target_image_view,                             //
                           const struct render_viewport_data views[XRT_MAX_VIEWS]);   //
diff --git a/src/xrt/compositor/shaders/distortion.comp b/src/xrt/compositor/shaders/distortion.comp
index 08b44d4cf..69d0a41b0 100644
--- a/src/xrt/compositor/shaders/distortion.comp
+++ b/src/xrt/compositor/shaders/distortion.comp
@@ -25,14 +25,12 @@ layout(set = 0, binding = 3, std140) uniform restrict Config
 	vec4 pre_transform[2];
 	vec4 post_transform[2];
 	mat4 transform[2];
+	vec2 src_sizes[2];
 } ubo;
 
 
-vec2 position_to_uv(ivec2 extent, uint ix, uint iy)
+vec2 position_to_uv(ivec2 extent, vec2 xy)
 {
-	// Turn the index into floating point.
-	vec2 xy = vec2(float(ix), float(iy));
-
 	// The inverse of the extent of the target image is the pixel size in [0 .. 1] space.
 	vec2 extent_pixel_size = vec2(1.0 / float(extent.x), 1.0 / float(extent.y));
 
@@ -102,6 +100,17 @@ vec2 transform_uv(vec2 uv, uint iz)
 	}
 }
 
+vec2 distorted_uv(ivec2 extent, vec2 xy, uint iz)
+{
+	vec2 dist_uv = position_to_uv(extent, xy);
+
+	// Only read red channel, we don't do color aberration
+	vec2 r_uv = texture(distortion[iz + 0], dist_uv).xy;
+
+	// Do any transformation needed.
+	return transform_uv(r_uv, iz);
+}
+
 void main()
 {
 	uint ix = gl_GlobalInvocationID.x;
@@ -110,29 +119,71 @@ void main()
 
 	ivec2 offset = ivec2(ubo.views[iz].xy);
 	ivec2 extent = ivec2(ubo.views[iz].zw);
+	ivec2 src_extent = ivec2(ubo.src_sizes[iz]);
 
 	if (ix >= extent.x || iy >= extent.y) {
 		return;
 	}
 
-	vec2 dist_uv = position_to_uv(extent, ix, iy);
+	// extent of the area to sample in normalized coordinates
+	vec2 u0 = distorted_uv(extent, max(vec2(0, 0), vec2(ix - 0.5, iy - 0.5)), iz);
+	vec2 u1 = distorted_uv(extent, min(extent, vec2(ix + 0.5, iy + 0.5)), iz);
 
-	vec2 r_uv = texture(distortion[iz + 0], dist_uv).xy;
-	vec2 g_uv = texture(distortion[iz + 2], dist_uv).xy;
-	vec2 b_uv = texture(distortion[iz + 4], dist_uv).xy;
+	if (u0.y > u1.y)
+	{
+		float tmp = u0.y;
+		u0.y = u1.y;
+		u1.y = tmp;
+	}
 
-	// Do any transformation needed.
-	r_uv = transform_uv(r_uv, iz);
-	g_uv = transform_uv(g_uv, iz);
-	b_uv = transform_uv(b_uv, iz);
+	// extent in pixel coordinates
+	vec2 p0 = u0 * (src_extent - 1);
+	vec2 p1 = u1 * (src_extent - 1);
+
+	// shrink by 1/2 pixel to prevent overlap
+	p0 += vec2(0.5);
+	p1 -= vec2(0.5);
+
+	// iteration area
+	vec2 i0, i1;
+	// If there is less than one pixel, just sample it
+	if (p1.x - p0.x <= 1)
+		i0.x = i1.x = distorted_uv(extent, vec2(ix, iy), iz).x * src_extent.x;
+	else
+	{
+		i0.x = floor(p0.x);
+		i1.x = ceil(p1.x);
+	}
+	if (p1.y - p0.y <= 1)
+		i0.y = i1.y = distorted_uv(extent, vec2(ix, iy), iz).y * src_extent.y;
+	else
+	{
+		i0.y = floor(p0.y);
+		i1.y = ceil(p1.y);
+	}
 
-	// Sample the source with distorted and chromatic-aberration corrected samples.
-	vec4 colour = vec4(
-		texture(source[iz], r_uv).r,
-		texture(source[iz], g_uv).g,
-		texture(source[iz], b_uv).b,
-		1);
+	vec4 colour = vec4(0, 0, 0, 1);
+
+	float count = 0;
+	for (float y = i0.y ; y <= i1.y ; y++) {
+		float wy = 1;
+		if (y < p0.y)
+			wy *= 1 - (p0.y - y);
+		if (y > p1.y)
+			wy *= 1 - (y - p1.y);
+		for (float x = i0.x; x <= i1.x; x++) {
+			float w = wy;
+			if (x < p0.x)
+				w *= 1 - (p0.x - x);
+			if (x > p1.x)
+				w *= 1 - (x - p1.x);
+			vec2 uv = (vec2(x, y) + 0.5) / src_extent;
+			colour.rgb += w * texture(source[iz], uv).rgb;
+			count += w;
+		}
+	}
 
+	colour /= count;
 	// Do colour correction here since there are no automatic conversion in hardware available.
 	colour = vec4(from_linear_to_srgb(colour.rgb), 1);
 
diff --git a/src/xrt/compositor/util/comp_render.h b/src/xrt/compositor/util/comp_render.h
index 653cc0e3d..384b304d7 100644
--- a/src/xrt/compositor/util/comp_render.h
+++ b/src/xrt/compositor/util/comp_render.h
@@ -126,6 +126,8 @@ struct comp_render_dispatch_data
 
 		// Target image view for distortion.
 		VkImageView target_unorm_view;
+
+		struct xrt_vec2 scratch_size[XRT_MAX_VIEWS];
 	} cs;
 };
 
diff --git a/src/xrt/compositor/util/comp_render_cs.c b/src/xrt/compositor/util/comp_render_cs.c
index 8201407ae..ea9d1f258 100644
--- a/src/xrt/compositor/util/comp_render_cs.c
+++ b/src/xrt/compositor/util/comp_render_cs.c
@@ -350,6 +350,7 @@ do_cs_distortion_from_scratch(struct render_compute *crc, const struct comp_rend
 	VkImageView src_image_views[XRT_MAX_VIEWS];
 	VkSampler src_samplers[XRT_MAX_VIEWS];
 	struct xrt_normalized_rect src_norm_rects[XRT_MAX_VIEWS];
+	struct xrt_vec2 src_sizes[XRT_MAX_VIEWS];
 
 	for (uint32_t i = 0; i < d->view_count; i++) {
 		// Data to be filled in.
@@ -367,6 +368,7 @@ do_cs_distortion_from_scratch(struct render_compute *crc, const struct comp_rend
 		src_image_views[i] = src_image_view;
 		src_samplers[i] = clamp_to_border_black;
 		src_norm_rects[i] = src_norm_rect;
+		src_sizes[i] = d->cs.scratch_size[i];
 	}
 
 	render_compute_projection(   //
@@ -374,6 +376,7 @@ do_cs_distortion_from_scratch(struct render_compute *crc, const struct comp_rend
 	    src_samplers,            // src_samplers
 	    src_image_views,         // src_image_views
 	    src_norm_rects,          // src_rects
+	    src_sizes,               // src_sizes
 	    d->cs.target_image,      // target_image
 	    d->cs.target_unorm_view, // target_image_view
 	    target_viewport_datas);  // views
@@ -402,6 +405,7 @@ do_cs_distortion_for_layer(struct render_compute *crc,
 	struct xrt_normalized_rect src_norm_rects[XRT_MAX_VIEWS];
 	struct xrt_pose src_poses[XRT_MAX_VIEWS];
 	struct xrt_fov src_fovs[XRT_MAX_VIEWS];
+	struct xrt_vec2 src_sizes[XRT_MAX_VIEWS];
 	VkSampler src_samplers[XRT_MAX_VIEWS];
 	VkImageView src_image_views[XRT_MAX_VIEWS];
 
@@ -435,6 +439,8 @@ do_cs_distortion_for_layer(struct render_compute *crc,
 		src_norm_rects[i] = src_norm_rect;
 		src_poses[i] = src_pose;
 		src_fovs[i] = src_fov;
+		src_sizes[i].x = layer->sc_array[i]->vkic.info.width;
+		src_sizes[i].y = layer->sc_array[i]->vkic.info.height;
 		src_samplers[i] = clamp_to_border_black;
 		src_image_views[i] = src_image_view;
 	}
@@ -445,6 +451,7 @@ do_cs_distortion_for_layer(struct render_compute *crc,
 		    src_samplers,            //
 		    src_image_views,         //
 		    src_norm_rects,          //
+		    src_sizes,               //
 		    d->cs.target_image,      //
 		    d->cs.target_unorm_view, //
 		    target_viewport_datas);  //
@@ -454,6 +461,7 @@ do_cs_distortion_for_layer(struct render_compute *crc,
 		    src_samplers,                   //
 		    src_image_views,                //
 		    src_norm_rects,                 //
+		    src_sizes,                      //
 		    src_poses,                      //
 		    src_fovs,                       //
 		    world_poses,                    //
