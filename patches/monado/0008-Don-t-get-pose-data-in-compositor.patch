From 959707499b31f8db80f28492d1bfc01e34b23368 Mon Sep 17 00:00:00 2001
From: no name <git-am@invalid>
Date: Thu, 15 Jan 2026 12:13:06 +0100
Subject: [PATCH 8/9] Don't get pose data in compositor

Reproject onto the first projection layer's pose, if there isn't any get
it from device instead.
---
 src/xrt/compositor/main/comp_renderer.c | 53 +++++++++++++++++++++----
 1 file changed, 45 insertions(+), 8 deletions(-)

diff --git a/src/xrt/compositor/main/comp_renderer.c b/src/xrt/compositor/main/comp_renderer.c
index ff9728a59..4a91bbcd0 100644
--- a/src/xrt/compositor/main/comp_renderer.c
+++ b/src/xrt/compositor/main/comp_renderer.c
@@ -948,6 +948,24 @@ dispatch_graphics(struct comp_renderer *r,
  *
  */
 
+static struct comp_layer *
+get_projection_layer(struct comp_layer_accum *layers)
+{
+	for (uint32_t layer = 0; layer < layers->layer_count; ++layer) {
+		switch (layers->layers[layer].data.type) {
+		case XRT_LAYER_PROJECTION:
+		case XRT_LAYER_PROJECTION_DEPTH: return &layers->layers[layer];
+		case XRT_LAYER_QUAD:
+		case XRT_LAYER_CUBE:
+		case XRT_LAYER_CYLINDER:
+		case XRT_LAYER_EQUIRECT1:
+		case XRT_LAYER_EQUIRECT2:
+		case XRT_LAYER_PASSTHROUGH: break;
+		}
+	}
+	return NULL;
+}
+
 /*!
  * @pre render_compute_init(render, &c->nr)
  */
@@ -972,14 +990,33 @@ dispatch_compute(struct comp_renderer *r,
 	struct xrt_pose world_poses_scanout_begin[XRT_MAX_VIEWS];
 	struct xrt_pose world_poses_scanout_end[XRT_MAX_VIEWS];
 	struct xrt_pose eye_poses[XRT_MAX_VIEWS];
-	calc_pose_data(                //
-	    r,                         //
-	    fov_source,                //
-	    fovs,                      //
-	    world_poses_scanout_begin, //
-	    world_poses_scanout_end,   //
-	    eye_poses,                 //
-	    render->r->view_count);    //
+	if (!c->base.frame_params.one_projection_layer_fast_path) {
+		struct comp_layer *proj_layer = get_projection_layer(&c->base.layer_accum);
+		int64_t predicted_display_time_ns = c->frame.rendering.predicted_display_time_ns;
+		int64_t cutoff_ns = 3 * c->frame_interval_ns;
+		if (proj_layer && llabs(predicted_display_time_ns - proj_layer->data.timestamp) <= cutoff_ns) {
+			struct xrt_layer_projection_view_data *data = proj_layer->data.proj.v;
+			// depth has the same first member as proj
+			for (int view = 0; view < XRT_MAX_VIEWS; ++view) {
+				fovs[view] = data[view].fov;
+				world_poses_scanout_begin[view] = data[view].pose;
+				world_poses_scanout_end[view] = data[view].pose;
+				eye_poses[view] = data[view].pose;
+
+				r->c->base.frame_params.fovs[view] = data[view].fov;
+				r->c->base.frame_params.poses[view] = data[view].pose;
+			}
+		} else {
+			calc_pose_data(                //
+			    r,                         //
+			    fov_source,                //
+			    fovs,                      //
+			    world_poses_scanout_begin, //
+			    world_poses_scanout_end,   //
+			    eye_poses,                 //
+			    render->r->view_count);    //
+		}
+	}
 
 	// Target Vulkan resources..
 	VkImage target_image = r->c->target->images[r->acquired_buffer].handle;
-- 
2.53.0

